package templates

import (
	"fmt"
	"bytes"
	"github.com/golang/protobuf/proto"
	"github.com/iancoleman/strcase"
	"path/filepath"

	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pkg/errors"
	"log"
	"strings"
	"text/template"
)

var code = `// Generated by protoc-gen-ts-web. DO NOT EDIT!
// package {{.Package}}

{{- $file := .}}
{{- $package := .Package}}

import * as grpcWeb from 'grpc-web';
{{if not (eq (len (imports .)) 0) }}
import {
{{- range $import := imports .}}
	{{stripPackage $import}},
	{{stripPackage $import}}Message,
{{- end}}
} from './{{importPath $file}}';
{{end}}

{{- range $service := .Service}}
export class {{.Name}} {

	private client = new grpcWeb.GrpcWebClientBase({
		format: 'text',
	});
{{range $method := .Method}}
	private methodInfo{{$method.Name}} = new grpcWeb.AbstractClientBase.MethodInfo(
		{{responseMessage $method $file}},
		(req: {{requestMessage $method $file}}) => req.serializeBinary(),
		{{responseMessage $method $file}}.deserializeBinary
	);
{{- end}}

	constructor(
		private hostname: string,
	) { }
{{range $method := .Method}}
	{{methodName $method}}(req: {{requestObject $method $file}}, metadata?: grpcWeb.Metadata): Promise<{{responseObject $method $file}}> {
		return new Promise((resolve, reject) => {
			this.client.rpcCall(
				this.hostname + '/{{$package}}.{{$service.GetName}}/{{$method.GetName}}',
				{{requestMessage $method $file}}.fromObject(req),
				metadata || {},
				this.methodInfo{{$method.Name}},
				(err: grpcWeb.Error, res: {{responseMessage $method $file}}) => {
					if (err) {
						reject(err);
					} else {
						resolve(res.toObject());
					}
				},
			);
		});
	}
{{- end}}
}
{{- end}}
`

var declarations = `import * as jspb from "google-protobuf"

{{range $message := .MessageType -}}
export interface {{messageObjectName $message}} {
{{- range $field := .Field}}
	{{camelFieldName $field}}: {{fieldType $field}},
{{- end}}
}

export class {{messageName $message}} extends jspb.Message {
{{range $field := .Field}}
	get{{pascalFieldName $field}}(): {{fieldType $field}} {
		return jspb.Message.getFieldWithDefault(this, {{$field.GetNumber}}, {{defaultValue $field}});
	}

	set{{pascalFieldName $field}}(value: {{fieldType $field}}): void {
		// todo: might need to use different "setField" variant
		// for different proto types
		// but i think the @types/google-protobuf is missing the definitions
		jspb.Message.setField(this, {{$field.Number}}, value);
	}
{{end}}
	serializeBinary(): Uint8Array {
		const writer = new jspb.BinaryWriter();
		let message: any;
{{- range $field := .Field}}
		message = this.get{{pascalFieldName $field}}();
		if (message.length > 0) {
			writer.write{{protoType $field}}({{$field.Number}}, message);
		}
{{- end}}
		return writer.getResultBuffer();
	}

	toObject(): {{messageObjectName $message}} {
		return {
{{- range $field := .Field}}
			{{camelFieldName $field}}: jspb.Message.getFieldWithDefault(this, {{$field.Number}}, {{defaultValue $field}}),
{{- end}}
		};
	}

	static fromObject(obj: {{messageObjectName $message}}): {{messageName $message}} {
		const message = new {{messageName $message}}();
{{- range $field := .Field}}
		message.set{{pascalFieldName $field}}(obj.{{camelFieldName $field}});
{{- end}}
		return message;
	}

	static deserializeBinary(bytes: Uint8Array): {{messageName $message}} {
		var reader = new jspb.BinaryReader(bytes);
		var message = new {{messageName $message}}();
		return {{messageName $message}}.deserializeBinaryFromReader(message, reader);
	}

	static deserializeBinaryFromReader(message: {{messageName $message}}, reader: jspb.BinaryReader): {{messageName $message}} {
		while (reader.nextField()) {
			if (reader.isEndGroup()) {
				break;
			}
			const field = reader.getFieldNumber();
			switch (field) {
{{- range $field := .Field}}
			case {{$field.Number}}:
				message.set{{pascalFieldName $field}}(reader.read{{protoType $field}}());
				break;
{{- end}}
			default:
				reader.skipField();
				break;
			}
		}
		return message;
	}

}

{{end}}

`

var funcs = template.FuncMap{
	"typeName": func(name *string) string {
		if name != nil && *name != "" {
			parts := strings.Split(*name, ".")
			return parts[len(parts)-1]
		}
		return ""
	},
	"imports": func(file *descriptor.FileDescriptorProto) []string {
		messages := []string{}
		if file != nil {
			for _, svc := range file.Service {
				for _, method := range svc.Method {
					if method.GetInputType() != "" {
						messages = append(messages, method.GetInputType())
					}
					if method.GetOutputType() != "" {
						messages = append(messages, method.GetOutputType())
					}
				}
			}
		}
		return unique(messages)
	},
	"importPath": func(file *descriptor.FileDescriptorProto) string {
		return filepath.Base(stripProto(file.GetName())) + "_pb.js"
	},
	"messageName": func(message *descriptor.DescriptorProto) string {
		return message.GetName() + "Message"
	},
	"messageObjectName": func(message *descriptor.DescriptorProto) string {
		return message.GetName()
	},
	"methodName": func(method *descriptor.MethodDescriptorProto) string {
		return strcase.ToLowerCamel(method.GetName())
	},
	"stripPackage": func(str string) string {
		parts := strings.Split(str, ".")
		return parts[len(parts)-1]
	},
	"requestObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
		return strings.TrimPrefix(method.GetInputType(), "."+file.GetPackage()+".")
	},
	"responseObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
		return strings.TrimPrefix(method.GetOutputType(), "."+file.GetPackage()+".")
	},
	"requestMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
		return strings.TrimPrefix(method.GetInputType(), "."+file.GetPackage()+".") + "Message"
	},
	"responseMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
		return strings.TrimPrefix(method.GetOutputType(), "."+file.GetPackage()+".") + "Message"
	},
	"pascalFieldName": func(field *descriptor.FieldDescriptorProto) string {
		return strcase.ToCamel(field.GetName())
	},
	"camelFieldName": func(field *descriptor.FieldDescriptorProto) string {
		return strcase.ToLowerCamel(field.GetName())
	},
	"fieldType": func(field *descriptor.FieldDescriptorProto) string {
		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			return "number"
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			return "string"
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			return "boolean"
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			return "Uint8Array | string"
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			panic("TODO support enums")
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			return field.GetTypeName()
		}
		log.Fatalf("unknown proto field type: %s", field.GetTypeName())
		return ""
	},
	"protoType": func(field *descriptor.FieldDescriptorProto) string {
		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
			return "Float"
		case descriptor.FieldDescriptorProto_TYPE_INT32:
			return "Int32"
		case descriptor.FieldDescriptorProto_TYPE_UINT32:
			return "Uint32"
		case descriptor.FieldDescriptorProto_TYPE_SINT32:
			return "SInt32"
		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
			return "Fixed32"
		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
			return "SFixed32"
		case descriptor.FieldDescriptorProto_TYPE_INT64:
			return "Int64"
		case descriptor.FieldDescriptorProto_TYPE_UINT64:
			return "UInt64"
		case descriptor.FieldDescriptorProto_TYPE_SINT64:
			return "SInt64"
		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
			return "Fixed64"
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			return "SFixed64"
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			return "Double"
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			return "String"
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			return "Boolean"
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			return "Bytes"
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			panic("TODO support enums")
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			panic("TODO support messages")
		}
		log.Fatalf("unknown proto field type: %s", field.GetTypeName())
		return ""
	},
	"defaultValue": func(field *descriptor.FieldDescriptorProto) string {
		switch (field.GetType()) {
		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			if field.GetDefaultValue() == "" {
				return "0"
			}
			return field.GetDefaultValue()
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			return fmt.Sprintf(`"%s"`, field.GetDefaultValue())
		}
		log.Fatalf("unknown default for proto field type: %s", field.GetTypeName())
		return ""
	},
}

func NewFile(file *descriptor.FileDescriptorProto) []*plugin.CodeGeneratorResponse_File {
	return []*plugin.CodeGeneratorResponse_File{
		&plugin.CodeGeneratorResponse_File{
			Name:    proto.String(stripProto(file.GetName()) + "_svc_pb.ts"),
			Content: proto.String(run(code, file)),
		},
		&plugin.CodeGeneratorResponse_File{
			Name:    proto.String(stripProto(file.GetName()) + "_pb.ts"),
			Content: proto.String(run(declarations, file)),
		},
	}
}

func run(tpl string, file *descriptor.FileDescriptorProto) string {
	t, err := template.New("").Funcs(funcs).Parse(tpl)
	if err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	buf := &bytes.Buffer{}
	if err := t.Execute(buf, file); err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	return buf.String()
}

func unique(strs []string) []string {
	keys := make(map[string]bool)
	list := []string{}
	for _, entry := range strs {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func stripProto(str string) string {
	return strings.TrimSuffix(str, ".proto")
}
