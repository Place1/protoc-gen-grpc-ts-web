package templates

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/iancoleman/strcase"

	"log"
	"strings"
	"text/template"

	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pkg/errors"
)

var code = `// Generated by protoc-gen-ts-web. DO NOT EDIT!
// package {{.Package}}

{{- $file := .}}
{{- $package := .Package}}

import * as jspb from 'google-protobuf';
import * as grpcWeb from 'grpc-web';

{{- if not (eq (len (.GetDependency)) 0) }}
{{range $dependency := .GetDependency}}
import * as {{ importNS $dependency }} from '{{importPath $dependency}}';
{{- end}}
{{- end}}

{{range $service := .Service -}}
export class {{.Name}} {

	private client = new grpcWeb.GrpcWebClientBase({
		format: 'text',
	});
{{range $method := .Method}}
	private methodInfo{{$method.Name}} = new grpcWeb.AbstractClientBase.MethodInfo(
		{{responseMessage $method $file}},
		(req: {{requestMessage $method $file}}) => req.serializeBinary(),
		{{responseMessage $method $file}}.deserializeBinary
	);
{{end}}
	constructor(
		private hostname: string,
	) { }
{{range $method := .Method}}
	{{methodName $method}}(req: {{requestObject $method $file}}, metadata?: grpcWeb.Metadata): Promise<{{responseObject $method $file}}> {
		return new Promise((resolve, reject) => {
			this.client.rpcCall(
				this.hostname + '/{{$package}}.{{$service.GetName}}/{{$method.GetName}}',
				{{requestMessage $method $file}}.fromObject(req),
				metadata || {},
				this.methodInfo{{$method.Name}},
				(err: grpcWeb.Error, res: {{responseMessage $method $file}}) => {
					if (err) {
						reject(err);
					} else {
						resolve(res.toObject());
					}
				},
			);
		});
	}
{{- end}}
}
{{- end}}

{{range $enum := .EnumType -}}
export enum {{$enum.GetName}} {
{{- range $value := .GetValue}}
	{{$value.GetName}} = {{$value.GetNumber}},
{{- end}}
}
{{- end}}

{{range $message := .MessageType -}}
export namespace {{messageName $message}} {
	export type AsObject = {
{{- range $field := .Field}}
		{{camelFieldName $field}}: {{fieldType $field $file}},
{{- end}}
	}
}

export class {{messageName $message}} extends jspb.Message {
{{range $field := .Field}}
	get{{pascalFieldName $field}}(): {{fieldType $field $file}} {
		return jspb.Message.getFieldWithDefault(this, {{$field.GetNumber}}, {{defaultValue $field}});
	}

	set{{pascalFieldName $field}}(value: {{fieldType $field $file}}): void {
		// todo: might need to use different "setField" variant
		// for different proto types
		// but i think the @types/google-protobuf is missing the definitions
		jspb.Message.setField(this, {{$field.Number}}, value);
	}
{{end}}
	serializeBinary(): Uint8Array {
		const writer = new jspb.BinaryWriter();
		let message: any;
{{- range $field := .Field}}
		message = this.get{{pascalFieldName $field}}();
		if (message.length > 0) {
			writer.write{{protoType $field}}({{$field.Number}}, message);
		}
{{- end}}
		return writer.getResultBuffer();
	}

	toObject(): {{messageObjectName $message}} {
		return {
{{- range $field := .Field}}
			{{camelFieldName $field}}: jspb.Message.getFieldWithDefault(this, {{$field.Number}}, {{defaultValue $field}}),
{{- end}}
		};
	}

	static fromObject(obj: {{messageObjectName $message}}): {{messageName $message}} {
		const message = new {{messageName $message}}();
{{- range $field := .Field}}
		message.set{{pascalFieldName $field}}(obj.{{camelFieldName $field}});
{{- end}}
		return message;
	}

	static deserializeBinary(bytes: Uint8Array): {{messageName $message}} {
		var reader = new jspb.BinaryReader(bytes);
		var message = new {{messageName $message}}();
		return {{messageName $message}}.deserializeBinaryFromReader(message, reader);
	}

	static deserializeBinaryFromReader(message: {{messageName $message}}, reader: jspb.BinaryReader): {{messageName $message}} {
		while (reader.nextField()) {
			if (reader.isEndGroup()) {
				break;
			}
			const field = reader.getFieldNumber();
			switch (field) {
{{- range $field := .Field}}
			case {{$field.Number}}:
				message.set{{pascalFieldName $field}}(reader.read{{protoType $field}}());
				break;
{{- end}}
			default:
				reader.skipField();
				break;
			}
		}
		return message;
	}

}

{{end}}
`

func funcmap(depLookup map[string]string) template.FuncMap {
	return template.FuncMap{
		"typeName": func(name *string) string {
			if name != nil && *name != "" {
				parts := strings.Split(*name, ".")
				return parts[len(parts)-1]
			}
			return ""
		},
		"messageImports": func(file *descriptor.FileDescriptorProto) []string {
			messages := []string{}
			if file != nil {
				for _, svc := range file.Service {
					for _, method := range svc.Method {
						if method.GetInputType() != "" {
							messages = append(messages, method.GetInputType())
						}
						if method.GetOutputType() != "" {
							messages = append(messages, method.GetOutputType())
						}
					}
				}
			}
			return unique(messages)
		},
		"messageName": func(message *descriptor.DescriptorProto) string {
			return message.GetName()
		},
		"messageObjectName": func(message *descriptor.DescriptorProto) string {
			return message.GetName() + ".AsObject"
		},
		"methodName": func(method *descriptor.MethodDescriptorProto) string {
			return strcase.ToLowerCamel(method.GetName())
		},
		"stripPackage": func(str string) string {
			return stripPackage(str)
		},
		"stripProto": func(str string) string {
			return stripProto(str)
		},
		"importPath": func(dependency string) string {
			if strings.HasPrefix(dependency, "google/protobuf") {
				return fmt.Sprintf("google-protobuf/%s_pb", stripProto(dependency))
			}
			return dependency
		},
		"importNS": func(dependency string) string {
			return protoPathToNS(dependency)
		},
		"requestObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup) + ".AsObject"
		},
		"responseObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup) + ".AsObject"
		},
		"requestMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup)
		},
		"responseMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup)
		},
		"pascalFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToCamel(field.GetName())
		},
		"camelFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToLowerCamel(field.GetName())
		},
		"fieldType": func(field *descriptor.FieldDescriptorProto, file *descriptor.FileDescriptorProto) string {
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return "number"
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return "string"
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				return "boolean"
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				return "Uint8Array | string"
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return stripPackage(field.GetTypeName()) // TODO: support properly
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return messageTypeToTS(field.GetTypeName(), file, depLookup)
			}
			log.Fatalf("unknown field type: %s", field.GetTypeName())
			return ""
		},
		"protoType": func(field *descriptor.FieldDescriptorProto) string {
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				return "Float"
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				return "Int32"
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				return "Uint32"
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				return "SInt32"
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				return "Fixed32"
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				return "SFixed32"
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				return "Int64"
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				return "UInt64"
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				return "SInt64"
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				return "Fixed64"
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				return "SFixed64"
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return "Double"
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return "String"
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				return "Boolean"
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				return "Bytes"
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return stripPackage(field.GetTypeName()) // TODO: support properly
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return stripPackage(field.GetTypeName()) // TODO: support properly
			}
			log.Fatalf("unknown proto type: %s", field.GetTypeName())
			return ""
		},
		"defaultValue": func(field *descriptor.FieldDescriptorProto) string {
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				if field.GetDefaultValue() == "" {
					return "0"
				}
				return field.GetDefaultValue()
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return fmt.Sprintf(`"%s"`, field.GetDefaultValue())
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return field.GetDefaultValue() // TODO: support this properly
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return stripPackage(field.GetTypeName()) // TODO: support this properly
			}
			log.Fatalf("unknown default for proto field type: %s", field.GetType())
			return ""
		},
	}
}

func NewFile(file *descriptor.FileDescriptorProto, depLookup map[string]string) []*plugin.CodeGeneratorResponse_File {
	// well-known proto files from google/protobuf will
	// be provided by the google-protobuf npm package
	if strings.HasPrefix(file.GetName(), "google/protobuf") {
		return []*plugin.CodeGeneratorResponse_File{}
	}
	return []*plugin.CodeGeneratorResponse_File{
		&plugin.CodeGeneratorResponse_File{
			Name:    proto.String(stripProto(file.GetName()) + "_pb.ts"),
			Content: proto.String(run(code, file, depLookup)),
		},
	}
}

func run(tpl string, file *descriptor.FileDescriptorProto, depLookup map[string]string) string {
	t, err := template.New("").Funcs(funcmap(depLookup)).Parse(tpl)
	if err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	buf := &bytes.Buffer{}
	if err := t.Execute(buf, file); err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	return buf.String()
}

func unique(strs []string) []string {
	keys := make(map[string]bool)
	list := []string{}
	for _, entry := range strs {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func stripProto(str string) string {
	return strings.TrimSuffix(str, ".proto")
}

func stripPackage(str string) string {
	parts := strings.Split(str, ".")
	return parts[len(parts)-1]
}

func protoPathToNS(path string) string {
	path = stripProto(path)
	parts := strings.Split(path, "/")
	return strcase.ToLowerCamel(strings.Join(parts, "_"))
}

func messageTypeToTS(typeName string, currentFile *descriptor.FileDescriptorProto, depLookup map[string]string) string {
	depfile, ok := depLookup[typeName]
	if !ok {
		return "any" // TODO: we didn't find the message in any input protos
	}
	if depfile != currentFile.GetName() {
		return fmt.Sprintf("%s.%s", protoPathToNS(depfile), stripPackage(typeName))
	}
	return stripPackage(typeName)
}
