package templates

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/iancoleman/strcase"

	"log"
	"strings"
	"text/template"

	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pkg/errors"
)

var code = `// Generated by protoc-gen-grpc-ts-web. DO NOT EDIT!

{{- $file := .}}
{{- $package := .Package}}

import * as jspb from 'google-protobuf';
import * as grpcWeb from 'grpc-web';

{{- if not (eq (len (.GetDependency)) 0) }}
{{range $dependency := .GetDependency}}
import * as {{ importNS $dependency }} from '{{importPath $dependency}}';
{{- end}}
{{- end}}

{{range $service := .Service -}}
export class {{.Name}} {

	private client = new grpcWeb.GrpcWebClientBase({
		format: 'text',
	});
{{range $method := .Method}}
	private methodInfo{{$method.Name}} = new grpcWeb.AbstractClientBase.MethodInfo(
		{{responseMessage $method $file}},
		(req: {{requestMessage $method $file}}) => req.serializeBinary(),
		{{responseMessage $method $file}}.deserializeBinary
	);
{{end}}
	constructor(
		private hostname: string,
		private defaultMetadata?: () => grpcWeb.Metadata,
	) { }
{{range $method := .Method}}
{{- if not $method.ClientStreaming -}}
{{- if not $method.ServerStreaming}}
	{{methodName $method}}(req: {{requestObject $method $file}}, metadata?: grpcWeb.Metadata): Promise<{{responseObject $method $file}}> {
		return new Promise((resolve, reject) => {
			const message = new {{requestMessage $method $file}}();
{{- range $field := (typeToMessageProto $method.GetInputType).GetField}}
			message.set{{pascalFieldName $field}}(req.{{camelFieldName $field}});
{{- end}}
			this.client.rpcCall(
				this.hostname + '/{{$package}}.{{$service.GetName}}/{{$method.GetName}}',
				message,
				Object.assign({}, this.defaultMetadata ? this.defaultMetadata() : {}, metadata),
				this.methodInfo{{$method.Name}},
				(err: grpcWeb.Error, res: {{responseMessage $method $file}}) => {
					if (err) {
						reject(err);
					} else {
						resolve(res.toObject());
					}
				},
			);
		});
	}
{{end -}}
{{- end -}}
{{- if not $method.ClientStreaming -}}
{{- if $method.ServerStreaming}}
	{{methodName $method}}(req: {{requestObject $method $file}}, metadata?: grpcWeb.Metadata) {
		const message = new {{requestMessage $method $file}}();
{{- range $field := (typeToMessageProto $method.GetInputType).GetField}}
		message.set{{pascalFieldName $field}}(req.{{camelFieldName $field}});
{{- end}}
		const stream = this.client.serverStreaming(
			this.hostname + '/{{$package}}.{{$service.GetName}}/{{$method.GetName}}',
			message,
			Object.assign({}, this.defaultMetadata ? this.defaultMetadata() : {}, metadata),
			this.methodInfo{{$method.Name}},
		);
		return {
			onError(callback: (err: grpcWeb.Error) => void) {
				stream.on('error', callback);
			},
			onStatus(callback: (status: grpcWeb.Status) => void) {
				stream.on('status', callback);
			},
			onData(callback: (response: {{responseObject $method $file}}) => void) {
				stream.on('data', (message) => {
					callback(message.toObject());
				});
			},
			onEnd(callback: () => void) {
				stream.on('end', callback);
			},
			cancel() {
				stream.cancel();
			},
		};
	}
{{end -}}
{{- end -}}
{{end}}
}
{{- end}}

{{range $enum := .EnumType -}}
export enum {{$enum.GetName}} {
{{- range $value := .GetValue}}
	{{$value.GetName}} = {{$value.GetNumber}},
{{- end}}
}
{{- end}}

{{range $message := .MessageType -}}
export namespace {{messageName $message $file}} {
	export type AsObject = {
{{- range $field := .Field}}
		{{camelFieldName $field}}: {{fieldType $field $file}},
{{- end}}
	}
}

export class {{messageName $message $file}} extends jspb.Message {
{{range $field := .Field}}
	get{{pascalFieldName $field}}(): {{fieldType $field $file}} {
		return jspb.Message.getFieldWithDefault(this, {{$field.GetNumber}}, {{defaultValue $field}});
	}

	set{{pascalFieldName $field}}(value: {{fieldType $field $file}}): void {
		jspb.Message.{{jspbFieldSetter $field}}(this, {{$field.Number}}, value);
	}

	{{- if (isRepeated $field)}}
	{{if (isMessage $field)}}
	add{{pascalFieldName $field}}(value: {{fieldTypeName $field $file}}, index?: number): {{fieldTypeName $field $file}} {
		return jspb.Message.addToRepeatedWrapperField(this, {{$field.Number}}, value, {{fieldTypeName $field $file}}, index);
	}
	{{- end -}}
	{{if not (isMessage $field)}}
	add{{pascalFieldName $field}}(value: {{fieldTypeName $field $file}}, index?: number): void {
		return jspb.Message.addToRepeatedField(this, {{$field.Number}}, value, index);
	}
	{{- end -}}
	{{end}}
{{end}}
	serializeBinary(): Uint8Array {
		const writer = new jspb.BinaryWriter();
		{{messageName $message $file}}.serializeBinaryToWriter(this, writer);
		return writer.getResultBuffer();
	}

	toObject(): {{messageObjectName $message}} {
		return {
{{- range $field := .Field}}
			{{camelFieldName $field}}: jspb.Message.getFieldWithDefault(this, {{$field.Number}}, {{defaultValue $field}}),
{{- end}}
		};
	}

	static fromObject(obj: {{messageObjectName $message}}): {{messageName $message $file}} {
		const message = new {{messageName $message $file}}();
{{- range $field := .Field}}
		message.set{{pascalFieldName $field}}(obj.{{camelFieldName $field}});
{{- end}}
		return message;
	}

	static serializeBinaryToWriter(message: {{messageName $message $file}}, writer: jspb.BinaryWriter): void {
{{- range $field := .Field}}
		const field{{$field.Number}} = message.get{{pascalFieldName $field}}();
		if (field{{$field.Number}}{{zeroCheck $field}}) {
			writer.{{binaryWriterMethodName $field}}({{$field.Number}}, field{{$field.Number}}
				{{- if (isMessage $field) -}}
				, {{fieldTypeName $field $file}}.serializeBinaryToWriter
				{{- end -}}
			);
		}
{{- end}}
	}

	static deserializeBinary(bytes: Uint8Array): {{messageName $message $file}} {
		var reader = new jspb.BinaryReader(bytes);
		var message = new {{messageName $message $file}}();
		return {{messageName $message $file}}.deserializeBinaryFromReader(message, reader);
	}

	static deserializeBinaryFromReader(message: {{messageName $message $file}}, reader: jspb.BinaryReader): {{messageName $message $file}} {
		while (reader.nextField()) {
			if (reader.isEndGroup()) {
				break;
			}
			const field = reader.getFieldNumber();
			switch (field) {
{{- range $field := .Field}}
			case {{$field.Number}}:
{{- if not (isMessage $field)}}
				const field{{$field.Number}} = reader.{{binaryReaderMethodName $field}}()
{{- end -}}
{{- if (isMessage $field)}}
				const field{{$field.Number}} = new {{fieldTypeName $field $file}}();
				reader.{{binaryReaderMethodName $field}}(field{{$field.Number}}, {{fieldTypeName $field $file}}.deserializeBinaryFromReader);
{{- end}}
{{- if (isRepeated $field)}}
				message.add{{pascalFieldName $field}}(field{{$field.Number}});
{{- end}}
{{- if not (isRepeated $field)}}
				message.set{{pascalFieldName $field}}(field{{$field.Number}});
{{- end}}
				break;
{{- end}}
			default:
				reader.skipField();
				break;
			}
		}
		return message;
	}

}

{{end}}
`

func funcmap(depLookup map[string]Dependency) template.FuncMap {
	funcs := template.FuncMap{
		"methodName": func(method *descriptor.MethodDescriptorProto) string {
			return strcase.ToLowerCamel(method.GetName())
		},
		"stripPackage": func(str string) string {
			return stripPackage(str)
		},
		"stripProto": func(str string) string {
			return stripProto(str)
		},
		"importPath": func(dependency string) string {
			if strings.HasPrefix(dependency, "google/protobuf") {
				return fmt.Sprintf("google-protobuf/%s_pb", stripProto(dependency))
			}
			return fmt.Sprintf("./%s_pb", stripProto(dependency))
		},
		"importNS": func(dependency string) string {
			return protoPathToNS(dependency)
		},
		"messageName": func(message *descriptor.DescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(fmt.Sprintf(".%s.%s", file.GetPackage(), message.GetName()), file, depLookup)
		},
		"messageObjectName": func(message *descriptor.DescriptorProto) string {
			return message.GetName() + ".AsObject"
		},
		"requestObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup) + ".AsObject"
		},
		"responseObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup) + ".AsObject"
		},
		"requestMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup)
		},
		"responseMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup)
		},
		"pascalFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToCamel(field.GetName())
		},
		"camelFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToLowerCamel(field.GetName())
		},
		"typeToMessageProto": func(typeName string) *descriptor.DescriptorProto {
			if value, ok := depLookup[typeName]; ok {
				return value.Message
			}
			panic(fmt.Sprintf("unknown message type: %s", typeName))
		},
		"fieldTypeName": func(field *descriptor.FieldDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return fieldTypeName(field, file, depLookup)
		},
		"fieldType": func(field *descriptor.FieldDescriptorProto, file *descriptor.FileDescriptorProto) string {
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				return fmt.Sprintf("Array<%s>", fieldTypeName(field, file, depLookup))
			}
			return fieldTypeName(field, file, depLookup)
		},
		"isRepeated": func(field *descriptor.FieldDescriptorProto) bool {
			return field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED
		},
		"isMessage": func(field *descriptor.FieldDescriptorProto) bool {
			return field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE
		},
		"binaryWriterMethodName": func(field *descriptor.FieldDescriptorProto) string {
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				return fmt.Sprintf("writeRepeated%s", jspbBinaryReaderWriterMethodName(field))
			}
			return fmt.Sprintf("write%s", jspbBinaryReaderWriterMethodName(field))
		},
		"binaryReaderMethodName": func(field *descriptor.FieldDescriptorProto) string {
			return fmt.Sprintf("read%s", jspbBinaryReaderWriterMethodName(field))
		},
		"defaultValue": func(field *descriptor.FieldDescriptorProto) string {
			valueOr := func(value string, fallback string) string {
				if value == "" {
					return fallback
				}
				return value
			}
			defaultValue := func() string {
				switch field.GetType() {
				case descriptor.FieldDescriptorProto_TYPE_FLOAT:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_INT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_UINT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SINT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_FIXED32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_INT64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_UINT64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SINT64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_FIXED64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
					return valueOr(field.GetDefaultValue(), "0")
				case descriptor.FieldDescriptorProto_TYPE_BOOL:
					return valueOr(field.GetDefaultValue(), "false")
				case descriptor.FieldDescriptorProto_TYPE_BYTES:
					return fmt.Sprintf(`"%s"`, valueOr(field.GetDefaultValue(), ""))
				case descriptor.FieldDescriptorProto_TYPE_STRING:
					return fmt.Sprintf(`"%s"`, field.GetDefaultValue())
				case descriptor.FieldDescriptorProto_TYPE_ENUM:
					return valueOr(field.GetDefaultValue(), "0")
				case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
					return valueOr(field.GetDefaultValue(), "null")
				}
				log.Fatalf("unknown default for proto field type: %s", field.GetType())
				return ""
			}
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				return fmt.Sprintf("[%s]", defaultValue())
			}
			return defaultValue()
		},
		"zeroCheck": func(field *descriptor.FieldDescriptorProto) string {
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				return ".length > 0"
			}
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return " != 0.0"
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				return " != 0"
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				return " != false"
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return ".length > 0"
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return " != 0"
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return " != null"
			}
			log.Fatalf("unknown zero check for proto field type: %s", field.GetType())
			return ""
		},
		"jspbFieldSetter": func(field *descriptor.FieldDescriptorProto) string {
			if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
				if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
					return "setRepeatedWrapperField"
				}
				return "setWrapperField"
			}
			return "setField"
		},
		"jspbFieldAdder": func(field *descriptor.FieldDescriptorProto) string {
			if field.GetLabel() != descriptor.FieldDescriptorProto_LABEL_REPEATED {
				log.Fatal("jspbFieldAdder should only be used for repeated fields")
			}
			if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
				return "addToRepeatedWrapperField"
			}
			return "addToRepeatedField"
		},
	}
	return funcs
}

func NewFile(file *descriptor.FileDescriptorProto, depLookup map[string]Dependency) []*plugin.CodeGeneratorResponse_File {
	// well-known proto files from google/protobuf will
	// be provided by the google-protobuf npm package
	if strings.HasPrefix(file.GetName(), "google/protobuf") {
		return []*plugin.CodeGeneratorResponse_File{}
	}
	return []*plugin.CodeGeneratorResponse_File{
		&plugin.CodeGeneratorResponse_File{
			Name:    proto.String(stripProto(file.GetName()) + "_pb.ts"),
			Content: proto.String(run(code, file, depLookup)),
		},
	}
}

func run(tpl string, file *descriptor.FileDescriptorProto, depLookup map[string]Dependency) string {
	t, err := template.New("").Funcs(funcmap(depLookup)).Parse(tpl)
	if err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	buf := &bytes.Buffer{}
	if err := t.Execute(buf, file); err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	return buf.String()
}

func unique(strs []string) []string {
	keys := make(map[string]bool)
	list := []string{}
	for _, entry := range strs {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func stripProto(str string) string {
	return strings.TrimSuffix(str, ".proto")
}

func stripPackage(str string) string {
	parts := strings.Split(str, ".")
	return parts[len(parts)-1]
}

func protoPathToNS(path string) string {
	path = stripProto(path)
	parts := strings.Split(path, "/")
	return strcase.ToLowerCamel(strings.Join(parts, "_"))
}

func messageTypeToTS(typeName string, currentFile *descriptor.FileDescriptorProto, depLookup map[string]Dependency) string {
	depfile, ok := depLookup[typeName]
	if !ok {
		return "any" // TODO: we didn't find the message in any input protos
	}
	if depfile.File != currentFile.GetName() {
		return fmt.Sprintf("%s.%s", protoPathToNS(depfile.File), stripPackage(typeName))
	}
	return stripPackage(typeName)
}

type Dependency struct {
	File    string
	Message *descriptor.DescriptorProto
	Enum    *descriptor.EnumDescriptorProto
}

func NewDependencyLookupTable(req *plugin.CodeGeneratorRequest) map[string]Dependency {
	lookup := map[string]Dependency{}
	for _, f := range req.ProtoFile {
		for _, m := range f.GetMessageType() {
			qualified := fmt.Sprintf(".%s.%s", f.GetPackage(), m.GetName())
			lookup[qualified] = Dependency{
				File:    f.GetName(),
				Message: m,
			}
		}
		for _, e := range f.GetEnumType() {
			qualified := fmt.Sprintf(".%s.%s", f.GetPackage(), e.GetName())
			lookup[qualified] = Dependency{
				File: f.GetName(),
				Enum: e,
			}
		}
	}
	return lookup
}

func fieldTypeName(field *descriptor.FieldDescriptorProto, file *descriptor.FileDescriptorProto, depLookup map[string]Dependency) string {
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "number"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "Uint8Array | string"
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return messageTypeToTS(field.GetTypeName(), file, depLookup)
	}
	log.Fatalf("unknown field type: %s", field.GetTypeName())
	return ""
}

func jspbBinaryReaderWriterMethodName(field *descriptor.FieldDescriptorProto) string {
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return "Float"
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return "Int32"
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return "Uint32"
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "SInt32"
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return "Fixed32"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return "SFixed32"
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return "Int64"
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return "UInt64"
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return "SInt64"
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return "Fixed64"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return "SFixed64"
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "Double"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "String"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "Bool"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "Bytes"
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return "Enum"
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return "Message"
	}
	log.Fatalf("unknown proto type: %s", field.GetTypeName())
	return ""
}
