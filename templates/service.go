package templates

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/iancoleman/strcase"

	"log"
	"strings"
	"text/template"

	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pkg/errors"
)

var code = `// Generated by protoc-gen-ts-web. DO NOT EDIT!
// package {{.Package}}

{{- $file := .}}
{{- $package := .Package}}

import * as jspb from 'google-protobuf';
import * as grpcWeb from 'grpc-web';

{{- if not (eq (len (.GetDependency)) 0) }}
{{range $dependency := .GetDependency}}
import * as {{ importNS $dependency }} from '{{importPath $dependency}}';
{{- end}}
{{- end}}

{{range $service := .Service -}}
export class {{.Name}} {

	private client = new grpcWeb.GrpcWebClientBase({
		format: 'text',
	});
{{range $method := .Method}}
	private methodInfo{{$method.Name}} = new grpcWeb.AbstractClientBase.MethodInfo(
		{{responseMessage $method $file}},
		(req: {{requestMessage $method $file}}) => req.serializeBinary(),
		{{responseMessage $method $file}}.deserializeBinary
	);
{{end}}
	constructor(
		private hostname: string,
	) { }
{{range $method := .Method}}
	{{methodName $method}}(req: {{requestObject $method $file}}, metadata?: grpcWeb.Metadata): Promise<{{responseObject $method $file}}> {
		return new Promise((resolve, reject) => {
			const message = new {{requestMessage $method $file}}();
{{- range $field := (typeToMessageProto $method.GetInputType).GetField}}
			message.set{{pascalFieldName $field}}(req.{{camelFieldName $field}});
{{- end}}
			this.client.rpcCall(
				this.hostname + '/{{$package}}.{{$service.GetName}}/{{$method.GetName}}',
				message,
				metadata || {},
				this.methodInfo{{$method.Name}},
				(err: grpcWeb.Error, res: {{responseMessage $method $file}}) => {
					if (err) {
						reject(err);
					} else {
						resolve(res.toObject());
					}
				},
			);
		});
	}
{{- end}}
}
{{- end}}

{{range $enum := .EnumType -}}
export enum {{$enum.GetName}} {
{{- range $value := .GetValue}}
	{{$value.GetName}} = {{$value.GetNumber}},
{{- end}}
}
{{- end}}

{{range $message := .MessageType -}}
export namespace {{messageName $message $file}} {
	export type AsObject = {
{{- range $field := .Field}}
		{{camelFieldName $field}}: {{fieldType $field $file}},
{{- end}}
	}
}

export class {{messageName $message $file}} extends jspb.Message {
{{range $field := .Field}}
	get{{pascalFieldName $field}}(): {{fieldType $field $file}} {
		return jspb.Message.getFieldWithDefault(this, {{$field.GetNumber}}, {{defaultValue $field}});
	}

	set{{pascalFieldName $field}}(value: {{fieldType $field $file}}): void {
		jspb.Message.{{jspbFieldSetter $field}}(this, {{$field.Number}}, value);
	}
{{end}}
	serializeBinary(): Uint8Array {
		const writer = new jspb.BinaryWriter();
		let message: any;
{{- range $field := .Field}}
		message = this.get{{pascalFieldName $field}}();
		if (message.length > 0) {
			writer.write{{jspbProtoTypeMethodName $field}}({{$field.Number}}, message
				{{- if eq (jspbProtoTypeMethodName $field) "Message" -}}
				, {{fieldType $field $file}}.serializeBinaryToWriter
				{{- end -}}
			);
		}
{{- end}}
		return writer.getResultBuffer();
	}

	toObject(): {{messageObjectName $message}} {
		return {
{{- range $field := .Field}}
			{{camelFieldName $field}}: jspb.Message.getFieldWithDefault(this, {{$field.Number}}, {{defaultValue $field}}),
{{- end}}
		};
	}

	static fromObject(obj: {{messageObjectName $message}}): {{messageName $message $file}} {
		const message = new {{messageName $message $file}}();
{{- range $field := .Field}}
		message.set{{pascalFieldName $field}}(obj.{{camelFieldName $field}});
{{- end}}
		return message;
	}

	static deserializeBinary(bytes: Uint8Array): {{messageName $message $file}} {
		var reader = new jspb.BinaryReader(bytes);
		var message = new {{messageName $message $file}}();
		return {{messageName $message $file}}.deserializeBinaryFromReader(message, reader);
	}

	static deserializeBinaryFromReader(message: {{messageName $message $file}}, reader: jspb.BinaryReader): {{messageName $message $file}} {
		while (reader.nextField()) {
			if (reader.isEndGroup()) {
				break;
			}
			const field = reader.getFieldNumber();
			switch (field) {
{{- range $field := .Field}}
			case {{$field.Number}}:
{{- if ne (jspbProtoTypeMethodName $field) "Message"}}
				message.set{{pascalFieldName $field}}(reader.read{{jspbProtoTypeMethodName $field}}());
{{- end -}}
{{- if eq (jspbProtoTypeMethodName $field) "Message"}}
				const {{camelFieldName $field}} = new {{fieldType $field $file}}();
				reader.read{{jspbProtoTypeMethodName $field}}({{camelFieldName $field}}, {{fieldType $field $file}}.deserializeBinaryFromReader);
				message.set{{pascalFieldName $field}}({{camelFieldName $field}});
{{- end}}
				break;
{{- end}}
			default:
				reader.skipField();
				break;
			}
		}
		return message;
	}

}

{{end}}
`

func funcmap(depLookup map[string]Dependency) template.FuncMap {
	funcs := template.FuncMap{
		"methodName": func(method *descriptor.MethodDescriptorProto) string {
			return strcase.ToLowerCamel(method.GetName())
		},
		"stripPackage": func(str string) string {
			return stripPackage(str)
		},
		"stripProto": func(str string) string {
			return stripProto(str)
		},
		"importPath": func(dependency string) string {
			if strings.HasPrefix(dependency, "google/protobuf") {
				return fmt.Sprintf("google-protobuf/%s_pb", stripProto(dependency))
			}
			return dependency
		},
		"importNS": func(dependency string) string {
			return protoPathToNS(dependency)
		},
		"messageName": func(message *descriptor.DescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(fmt.Sprintf(".%s.%s", file.GetPackage(), message.GetName()), file, depLookup)
		},
		"messageObjectName": func(message *descriptor.DescriptorProto) string {
			return message.GetName() + ".AsObject"
		},
		"requestObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup) + ".AsObject"
		},
		"responseObject": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup) + ".AsObject"
		},
		"requestMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetInputType(), file, depLookup)
		},
		"responseMessage": func(method *descriptor.MethodDescriptorProto, file *descriptor.FileDescriptorProto) string {
			return messageTypeToTS(method.GetOutputType(), file, depLookup)
		},
		"pascalFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToCamel(field.GetName())
		},
		"camelFieldName": func(field *descriptor.FieldDescriptorProto) string {
			return strcase.ToLowerCamel(field.GetName())
		},
		"typeToMessageProto": func(typeName string) *descriptor.DescriptorProto {
			if value, ok := depLookup[typeName]; ok {
				return value.Message
			}
			panic(fmt.Sprintf("unknown message type: %s", typeName))
		},
		"fieldType": func(field *descriptor.FieldDescriptorProto, file *descriptor.FileDescriptorProto) string {
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return "number"
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return "string"
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				return "boolean"
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				return "Uint8Array | string"
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return stripPackage(field.GetTypeName()) // TODO: support properly
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return messageTypeToTS(field.GetTypeName(), file, depLookup)
			}
			log.Fatalf("unknown field type: %s", field.GetTypeName())
			return ""
		},
		"jspbProtoTypeMethodName": func(field *descriptor.FieldDescriptorProto) string {
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				return "Float"
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				return "Int32"
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				return "Uint32"
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				return "SInt32"
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				return "Fixed32"
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				return "SFixed32"
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				return "Int64"
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				return "UInt64"
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				return "SInt64"
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				return "Fixed64"
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				return "SFixed64"
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return "Double"
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return "String"
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				return "Boolean"
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				return "Bytes"
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return "Enum"
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return "Message"
			}
			log.Fatalf("unknown proto type: %s", field.GetTypeName())
			return ""
		},
		"defaultValue": func(field *descriptor.FieldDescriptorProto) string {
			valueOr := func(value string, fallback string) string {
				if value == "" {
					return fallback
				}
				return value
			}
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				return valueOr(field.GetDefaultValue(), "0")
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				return fmt.Sprintf(`"%s"`, field.GetDefaultValue())
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				return valueOr(field.GetDefaultValue(), "0")
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				return valueOr(field.GetDefaultValue(), "null")
			}
			log.Fatalf("unknown default for proto field type: %s", field.GetType())
			return ""
		},
		"jspbFieldSetter": func(field *descriptor.FieldDescriptorProto) string {
			if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
				return "setWrapperField"
			}
			return "setField"
		},
	}
	return funcs
}

func NewFile(file *descriptor.FileDescriptorProto, depLookup map[string]Dependency) []*plugin.CodeGeneratorResponse_File {
	// well-known proto files from google/protobuf will
	// be provided by the google-protobuf npm package
	if strings.HasPrefix(file.GetName(), "google/protobuf") {
		return []*plugin.CodeGeneratorResponse_File{}
	}
	return []*plugin.CodeGeneratorResponse_File{
		&plugin.CodeGeneratorResponse_File{
			Name:    proto.String(stripProto(file.GetName()) + "_pb.ts"),
			Content: proto.String(run(code, file, depLookup)),
		},
	}
}

func run(tpl string, file *descriptor.FileDescriptorProto, depLookup map[string]Dependency) string {
	t, err := template.New("").Funcs(funcmap(depLookup)).Parse(tpl)
	if err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	buf := &bytes.Buffer{}
	if err := t.Execute(buf, file); err != nil {
		log.Fatal(errors.Wrap(err, "bad service template"))
	}

	return buf.String()
}

func unique(strs []string) []string {
	keys := make(map[string]bool)
	list := []string{}
	for _, entry := range strs {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func stripProto(str string) string {
	return strings.TrimSuffix(str, ".proto")
}

func stripPackage(str string) string {
	parts := strings.Split(str, ".")
	return parts[len(parts)-1]
}

func protoPathToNS(path string) string {
	path = stripProto(path)
	parts := strings.Split(path, "/")
	return strcase.ToLowerCamel(strings.Join(parts, "_"))
}

func messageTypeToTS(typeName string, currentFile *descriptor.FileDescriptorProto, depLookup map[string]Dependency) string {
	depfile, ok := depLookup[typeName]
	if !ok {
		return "any" // TODO: we didn't find the message in any input protos
	}
	if depfile.File != currentFile.GetName() {
		return fmt.Sprintf("%s.%s", protoPathToNS(depfile.File), stripPackage(typeName))
	}
	return stripPackage(typeName)
}

type Dependency struct {
	File    string
	Message *descriptor.DescriptorProto
}

func NewDependencyLookupTable(req *plugin.CodeGeneratorRequest) map[string]Dependency {
	lookup := map[string]Dependency{}
	for _, f := range req.ProtoFile {
		for _, m := range f.GetMessageType() {
			qualified := fmt.Sprintf(".%s.%s", f.GetPackage(), m.GetName())
			lookup[qualified] = Dependency{
				File:    f.GetName(),
				Message: m,
			}
		}
	}
	return lookup
}
